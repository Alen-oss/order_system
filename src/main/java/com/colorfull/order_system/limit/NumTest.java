package com.colorfull.order_system.limit;

/**
 * Java浮点型精度详解
 *
 * Java基本类型：8种，boolean、char、byte、short、int、long、float、double
 * 1）boolean：布尔型，占用1字节
 * 2）char：字符型，占用2字节
 * 3）byte：字节型，占用1字节，byte也是整型类型，取值范围-128~127
 * 4）short：短整型，占用2字节
 * 5）int：整型，占用4字节
 * 6）long：长整型，占用8字节，为了和int类型区分，声明一个long型数据时需要在末尾上加上L，不能是小写的l，这会和1混淆
 * 7）float：单精度浮点型，占用4字节
 * 8）double：双精度浮点型，占用8字节
 *
 * 浮点型详解
 * 定义：带有小数部分的数据类型
 * Java默认的浮点型为double，如果要表示一个float需要在其后追加字母f或F
 *
 * 浮点数为什么会精度缺失：
 * 我们先要知道，小数转换成二进制的过程：不断乘以2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果
 * 对于十进制的0.2转化为二进制而言：0.2*2 = 0.4，整数部分为0，0.4*2 = 0.8，整数部分为0，0.8*2 = 1.6，整数部分为1，0.6*2 = 1.2，整数部分为1，0.2*2 = 0.4...进入无限循环
 * 所以0.2(D) = 0.00110..，无法精确转化成二进制小数，而计算机在表示一个数字时宽度是有限的，在存储时只能被截断，此时就会发生小数精度发生损失的情况
 * 关于二进制小数转换为十进制，0.101 = 1 * 2的负一次方 + 1 * 2的负三次方 = 0.5 + 0.125 = 0.625
 *
 * float类型，4字节，32bit，符号位占1bit，指数位占8bit，尾数占23bit
 * 指数代表10的几次方，其中指数也分为正负指数，即10的2次方、10的负2次方，所以指数这里设置偏移量，设置为127为偏移量，则指数-2对应125这样
 * double类型，8字节，64bit，符号位占1bit，指数位占11位，尾数占52位，指数偏移量为1023
 *
 * 浮点类型转换成整数类型时，多余的位数会被截断而不是四舍五入
 *
 * Math.ceil() // 向上取整
 * Math.floor() // 向下取整
 * Math.round() // 四舍五入
 */
public class NumTest {

    public static void main(String[] agrs) {
        // 0.1转化成二进制：
        // 0.1 * 2 = 0.2 0
        // 0.2 * 2 = 0.4 0
        // 0.4 * 2 = 0.8 0
        // 0.8 * 2 = 1.6 1
        // 0.6 * 2 = 1.2 1
        // 0.2 * 2 = 0.4 0 （开始循环）
        // 所以：0.1二进制为0.0（0011）（0011）
        //      0.2二进制为0.（0011）（0011）
        double num1 = 0.1;
        double num2 = 0.2;
        System.out.println(num1 + num2);
        System.out.println("向上取整：" + (long)Math.ceil(96.1));
        System.out.println("向下取整：" + (long)Math.floor(96.1));
        System.out.println("四舍五入：" + Math.round(96.1));
    }
}
